\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{multirow}
\usepackage[latin1]{inputenc}

\title{DividendFS}
\author{Superleaf1995}

\begin{document}
\maketitle

\section{Preface}
\textbf{DividendFS} (or \textbf{DFS} for short) surges from the idea that a simple filesystem should be designed to be as easy to implement for growing kernels, while being fast and reliable for more mature ones.
A main tradeoff of DFS is \textbf{size} for \textbf{speed}, which should be taken in account for all implementations.

\section{Node filesystem}

The interface in DFS assumes that the disk is a plain array.
All numbers and fields are assumed to be little endian, regardless of the platform the filesystem is at.
A 4NUL is a 4-byte sequence of pure NUL bytes (00h). This is deliberate to allow UTF-8/UTF-16 encodings on names.
All entries are 16-byte aligned.

\subsection{Partition descriptor}

Unlike other filesystems, the bootloader does not nescesarily needs to be within the root block, the bootloader can be in it's own 512 byte sector.
In the first block (boot block or partition start block), at the start of the sector a table, described below must be there for making a valid DFS partition:

\begin{table}
\centering
\begin{tabular}{ |c|c| }
\hline
Offset & Purpose \\
\hline
+0 & 4 & Identifier ASCII characters: 'DvFS' \\
+4 & 4 & DFS version, a valid implementation uses 00h \\
+8 & 8 & First journaling block
+16 & 8 & Max number of journaling blocks
+24 & 8 & Current number of journaling blocks
+32 & 8 & Root block
+40 & 8 & Bitmap granularity
+48 & 8 & Allocation bitmap location
+56 & 8 & Size of partition
\hline
\end{tabular}
\caption{Structure of the partition descriptor}
\end{table}

Bitmap granularity specifies the number of bytes that each bit represents in the partition bitmap. The bitmap is a sequence of bytes that represents n bytes from the partition. Size of this bitmap (in bytes) can be determined by using the following formula: (size_of_partition/bitmap_granularity)/8
Root block contains the UNIX equivalent of '/'.

\subsection{Node entry}

\begin{table}
\centering
\begin{tabular}{ |c|c| }
\hline
Offset & Size & Description \\
\hline
+0 & 8 & Next entry \\
+8 & 8 & First child entry \\
+16 & 8 & First fragment entry \\
+24 & 8 & Symbolic link entry \\
+32 & 8 & UTC Creation time \\
+40 & 8 & UTC Edition time \\
+48 & 2 & Group permissions \\
+50 & 2 & User permissions \\
+52 & 8 & OS-Specific extra data \\
+60 & 2 & Id of the OS who created this file \\
+62 & ... & 4NUL terminated string \\
\hline
\end{tabular}
\caption{Structure of a node entry}
\end{table}

A node describes an abstract file (first child entry is NUL) or a directory (first child entry is not NUL) or a symbolic link (symbolic link entry is not NUL). A symbolic link cannot have children and should be taken as a invalid node. A node without symbolic link and without file fragments and without child nodes (all NUL) should be discarded and promptly deleted from the list.

\begin{table}
\centering
\begin{tabular}{ |c|c| }
\hline
Offset & Size & Description \\
\hline
+0 & 8 & Next file fragment \\
+8 & 8 & Size \\
+16 & ... & Data blob \\
\hline
\end{tabular}
\caption{Structure of a file fragment}
\end{table}

A file fragment describes a piece of data blob with a size specified in the previous parameter. Consequent fragments should be placed after the obtained blob in memory, as they are sequential.

\section{Journaling filesystem}

\begin{table}
\centering
\begin{tabular}{ |c|c| }
\hline
Offset & Size & Description \\
\hline
+0 & 8 & Next journal entry \\
+8 & 8 & Type of event \\
+16 & 8 & Size of data blob \\
+24 & 8 & Location \\
+32 & 8 & Extra \\
+40 & ... & Data blob \\
\hline
\end{tabular}
\caption{Structure of a journal event}
\end{table}

\begin{table}
\centering
\begin{tabular}{ |c|c| }
\hline
Code & Name & Usage of location field & Usage of extra field & Description \\
\hline
01h & File modification & Node pointer & Contains the offset at which the modification should be applied at & Contains data that should replace old data, does not modify size of file \\
02h & Expand/Shrink & Node pointer & New size of file & Shrinks or expands a file and makes it's size to be "New size" \\
03h & Unlink from chain & Node pointer & Previous node in the list & Deletes a node and delinks it from a chain. If previous node is NUL then the field is ignored.
04h & Link to chain & Node pointer & Previous node in the list & Adds a node to a chain. If previous node is NUL then the field is ignored.
05h & Copy & Node pointer & Target parent & Copies node pointer (and it's children and file fragments) and adds it to the chain of target parent
06h & Change node descriptor & Node pointer & New node pointer & Replaces the contents of the node descriptor with a new node descriptor
07h & Resize & Direction & Offset & Forces the driver to make all node descriptors, journal descriptor, file fragments and any other data to be above offset, and update the root block accordingly. If direction is 01h then every data must be below offset, otherwise it must be above.
\hline
\end{tabular}
\caption{Types}
\end{table}

If an entry is corrupt (type is 00h, or Location and Extra fields are not 00h when N/A is specified) the event can be discarded safely.
The usage of journaling is entirely optional and is up to implementation on whenever or not to implement it.

\end{document}
